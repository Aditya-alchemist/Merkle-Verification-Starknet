"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.StarknetMerkleTree = exports.hashPair = exports.HashType = void 0;
exports.computePoseidonHashOnElements = computePoseidonHashOnElements;
exports.hashDataToHex = hashDataToHex;
exports.hashDataToBigint = hashDataToBigint;
const starknet_1 = require("starknet");
var HashType;
(function (HashType) {
    HashType["Pedersen"] = "Pedersen";
    HashType["Poseidon"] = "Poseidon";
})(HashType || (exports.HashType = HashType = {}));
function throwError(message) {
    throw new Error(message);
}
const leftChildIndex = (i) => 2 * i + 1;
const rightChildIndex = (i) => 2 * i + 2;
/**
 * Calculate the hash of 2 values, ordered before calculation.
 *
 * @param a - first value.
 * @param b - second value.
 * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.
 * @returns the hash of these data
 * @example
 * ```typescript
 * const hash = merkle.hasPair(34447789n, 158953n));
 * }
 * ```
 */
const hashPair = (a, b, hashType = HashType.Pedersen) => BigInt(a) - BigInt(b) >= 0n
    ? starknet_1.num.toBigInt(hashType == HashType.Pedersen ? starknet_1.ec.starkCurve.pedersen(b, a) : starknet_1.ec.starkCurve.poseidonHashMany([b, a]))
    : starknet_1.num.toBigInt(hashType == HashType.Pedersen ? starknet_1.ec.starkCurve.pedersen(a, b) : starknet_1.ec.starkCurve.poseidonHashMany([a, b]));
exports.hashPair = hashPair;
/**
 * Compute Poseidon hash from data
 *  @param data - Array of hex string.
 * @returns format: bigint - poseidon hash
 */
function computePoseidonHashOnElements(data) {
    const dataBigint = data.map((val) => BigInt(val));
    return starknet_1.ec.starkCurve.poseidonHashMany([0n, ...dataBigint, BigInt(dataBigint.length)]);
}
/**
 * Calculate the hash of data formatted in {@link InputForMerkle}
 * and returns a HexString.
 *
 * @param data - array of Hex string
 * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.
 * @returns the hash of these data in HexString format
 * @example
 * ```typescript
 * const hashHex = merkle.hashDataToHex(["0x23a56e","0x1e54","0x34cc65"]), HashType.Pedersen);
 * }
 * ```
 */
function hashDataToHex(data, hashType = HashType.Pedersen) {
    let aa = [];
    if (Array.isArray(data)) {
        aa = data;
    }
    else {
        aa.push(data);
    }
    return starknet_1.encode.addHexPrefix(hashType == HashType.Pedersen ? starknet_1.ec.starkCurve.computeHashOnElements(aa).toString(16) : computePoseidonHashOnElements(aa).toString(16));
}
/**
 * Calculate the hash of data formatted in {@link InputForMerkle}
 * and returns a bigint.
 *
 * @param data - array of Hex string
 * @param hashType - optional. The type of hash : HashType.Pedersen (by default) or HashType.Poseidon.
 * @returns the hash of these data in bigint format
 * @example
 * ```typescript
 * const hashBigint = merkle.hashDataToBigint("0x23a5765C332d8f6e"), HashType.Pedersen);
 * }
 * ```
 */
function hashDataToBigint(data, hashType = HashType.Pedersen) {
    let aa = [];
    if (Array.isArray(data)) {
        aa = data;
    }
    else {
        aa.push(data);
    }
    return hashType == HashType.Pedersen ? BigInt(starknet_1.ec.starkCurve.computeHashOnElements(aa)) : computePoseidonHashOnElements(aa);
}
function makeMerkleTree(leaves, hashType = HashType.Pedersen) {
    if (leaves.length === 0) {
        throw new Error('Expected non-zero number of leaves');
    }
    const tree = new Array(2 * leaves.length - 1);
    // eslint-disable-next-line no-restricted-syntax
    for (const [i, leaf] of leaves.entries()) {
        tree[tree.length - 1 - i] = leaf;
    }
    for (let i = tree.length - 1 - leaves.length; i >= 0; i -= 1) {
        tree[i] = (0, exports.hashPair)(tree[leftChildIndex(i)], tree[rightChildIndex(i)], hashType);
    }
    return tree;
}
function isValidMerkleTree(tree, hashType = HashType.Pedersen) {
    // eslint-disable-next-line no-restricted-syntax
    for (const [i, node] of tree.entries()) {
        const l = leftChildIndex(i);
        const r = rightChildIndex(i);
        if (r >= tree.length) {
            if (l < tree.length) {
                return false;
            }
        }
        else if (!(node === (0, exports.hashPair)(tree[l], tree[r]), hashType)) {
            return false;
        }
    }
    return tree.length > 0;
}
const isTreeNode = (tree, i) => i >= 0 && i < tree.length;
const isInternalNode = (tree, i) => isTreeNode(tree, leftChildIndex(i));
const isLeafNode = (tree, i) => isTreeNode(tree, i) && !isInternalNode(tree, i);
const checkLeafNode = (tree, i) => isLeafNode(tree, i) || throwError('Index is not a leaf');
const parentIndex = (i) => i > 0 ? Math.floor((i - 1) / 2) : throwError('Root has no parent');
const siblingIndex = (i) => i > 0 ? i - (-1) ** (i % 2) : throwError('Root has no siblings');
function getProof(tree, index) {
    checkLeafNode(tree, index);
    // eslint-disable-next-line prefer-const
    let idx = index;
    const proof = [];
    while (idx > 0) {
        proof.push(tree[siblingIndex(idx)]);
        idx = parentIndex(idx);
    }
    return proof;
}
function biToHex(b) {
    return starknet_1.encode.addHexPrefix(b.toString(16));
}
function processProof(leaf, proof, hashType) {
    return proof.reduce((x, y) => (0, exports.hashPair)(x, y, hashType), leaf);
}
function renderMerkleTree(tree) {
    if (tree.length === 0) {
        throw new Error('Expected non-zero number of nodes');
    }
    const stack = [[0, []]];
    const lines = [];
    while (stack.length > 0) {
        const [i, path] = stack.pop();
        lines.push(
        // eslint-disable-next-line prefer-template
        path
            .slice(0, -1)
            .map((p) => ['   ', '│  '][p])
            .join('') +
            path
                .slice(-1)
                .map((p) => ['└─ ', '├─ '][p])
                .join('') +
            i +
            ') ' +
            starknet_1.encode.addHexPrefix(tree[i].toString(16)));
        if (rightChildIndex(i) < tree.length) {
            stack.push([rightChildIndex(i), path.concat(0)]);
            stack.push([leftChildIndex(i), path.concat(1)]);
        }
    }
    return lines.join('\n');
}
/**
 * Class for handling Merkle trees.
 */
class StarknetMerkleTree {
    constructor(tree, values, hashLookup, hashType = HashType.Pedersen) {
        this.tree = tree;
        this.values = values;
        this.hashLookup = hashLookup;
        this.hashType = hashType;
    }
    static adaptInputItem(element) {
        return starknet_1.num.getHexString(element);
    }
    /**
     * Creates a standard Merkle tree out of an array.
     *
     * @param values - the content of each leaf of the tree.
     * @param hashType - the type of hash : HashType.Pedersen or HashType.Poseidon.
     *
     * @returns a Merkle tree object
     * @example
     * ```typescript
     * const data: merkle.inputForMerkle[] = [
     *   ['0x69b49c2cc8b16e80e86bfc5b0614a59aa8c9b601569c7b80dde04d3f3151b79', '256'],
     *   ['0x3cad9a072d3cf29729ab2fad2e08972b8cfde01d4979083fb6d15e8e66f8ab1', '25'],
     *   ['0x27d32a3033df4277caa9e9396100b7ca8c66a4ef8ea5f6765b91a7c17f0109c', '56'],
     *   ['0x7e00d496e324876bbc8531f2d9a82bf154d1a04a50218ee74cdd372f75a551a', '26'],
     *   ['0x53c615080d35defd55569488bc48c1a91d82f2d2ce6199463e095b4a4ead551', '56'],
     * ];
     * const tree = merkle.StarknetMerkleTree.create(data);
     * ```
     */
    static create(values, hashType = HashType.Pedersen) {
        // verification of inputs
        const checkedValues = values.map((item) => {
            if (typeof item === 'string') {
                return StarknetMerkleTree.adaptInputItem(item);
            }
            return item.map(StarknetMerkleTree.adaptInputItem);
        });
        // calculate and store
        const hashedValues = checkedValues
            .map((value, valueIndex) => ({ val: value, valueInd: valueIndex, hash: hashDataToBigint(value, hashType) }))
            .sort((a, b) => (a.hash - b.hash >= 0n ? 1 : -1));
        const tree = makeMerkleTree(hashedValues.map((v) => v.hash), hashType);
        const indexedValues = checkedValues.map((value) => ({ value, treeIndex: 0 }));
        // eslint-disable-next-line no-restricted-syntax
        for (const [leafIndex, { valueInd }] of hashedValues.entries()) {
            indexedValues[valueInd].treeIndex = tree.length - leafIndex - 1;
        }
        const mapping = checkedValues.map((value, valueIndex) => {
            return [hashDataToHex(value, hashType), valueIndex];
        });
        const hashLookup = Object.fromEntries(mapping);
        return new StarknetMerkleTree(tree, indexedValues, hashLookup, hashType);
    }
    /**
     * return the nth data used for the tree creation.
     *
     * @param pos - input data order (0 first).
     * @returns
     * @example
     * ```typescript
     * const data= tree.getInputData(3);
     * ```
     */
    getInputData(pos) {
        return this.values[pos].value;
    }
    /**
     * Loads the tree from a description previously returned by {@link dump}.
     *
     * @param data - storage of Merkle tree.
     * @returns - a merkle tree description
     * @example
     * ```typescript
     * StarknetMerkleTree.load(JSON.parse(fs.readFileSync('tree.json','ascii')));
     * ```
     */
    static load(data) {
        if (data.format !== 'standard-v2') {
            throw new Error(`Unknown format '${data.format}'`);
        }
        return new StarknetMerkleTree(data.tree.map(BigInt), data.values, data.hashLookup, data.hashType);
    }
    /**
     * Returns a description of the merkle tree for distribution.
     * It contains all the necessary information to reproduce the tree,
     * find the relevant leaves, and generate proofs.
     * You should distribute this to users in a web application
     * so they can generate proofs for their leaves of interest.
     *
     * @returns - a merkle tree description
     * @example
     * ```typescript
     * fs.writeFileSync('tree.json', JSON.stringify(tree.dump(),undefined,2));
     * ```
     */
    dump() {
        return {
            format: 'standard-v2',
            tree: this.tree.map(biToHex),
            values: this.values,
            hashLookup: this.hashLookup,
            hashType: this.hashType == HashType.Pedersen ? HashType.Pedersen : HashType.Poseidon,
        };
    }
    /**
     * Returns a visual representation of the tree that can be useful for debugging.
     *
     * @returns string containing the result.
     * @example
     * ```typescript
     * console.log(tree.render());
     * ```
     */
    render() {
        return renderMerkleTree(this.tree);
    }
    /**
     * The root of the tree is a commitment on the values of the tree. It can be
     * published in a smart contract, to later prove that its values are part
     * of the tree.
     *
     * @returns an HexString ("0x1e3")
     * @example
     * ```typescript
     * console.log(tree.root);
     * ```
     */
    get root() {
        return starknet_1.encode.addHexPrefix(this.tree[0].toString(16));
    }
    /**
     * Lists the values in the tree along with their indices,
     * which can be used to obtain proofs.
     *
     * @example
     * ```typescript
     * for (const [i, v] of tree.entries()) {
     * console.log('value:', v);
     * console.log('proof:', tree.getProof(i));
     * }
     * ```
     */
    *entries() {
        // eslint-disable-next-line no-restricted-syntax
        for (const [i, { value }] of this.values.entries()) {
            yield [i, value];
        }
    }
    /**
     * Verify the consistency of the tree. Useful after a load().
     * Take care that this method is time-consuming.
     * Throw an error if validation fail.
     * @example
     * ```typescript
     * tree.validate();
     * ```
     */
    validate() {
        for (let i = 0; i < this.values.length; i += 1) {
            this.validateValue(i);
        }
        if (!isValidMerkleTree(this.tree, this.hashType)) {
            throw new Error('Merkle tree is invalid');
        }
    }
    /**
     * Returns the leaf hash of the value.
     *
     * @param leaf - the data contained in a leaf.
     * @param hashType - The type of hash : HashType.Pedersen or HashType.Poseidon.
     * @returns the hash of these data, stored at the base of the tree.
     * @example
     * ```typescript
     * const leaf = merkle.leafHash(["0x1e6f3", '100'], HashType.Pedersen);
     * }
     * ```
     */
    static leafHash(leaf, hashType) {
        if (typeof leaf === 'string') {
            return hashDataToHex(StarknetMerkleTree.adaptInputItem(leaf), hashType);
        }
        const adaptedLeaf = leaf.map(StarknetMerkleTree.adaptInputItem);
        return hashDataToHex(adaptedLeaf, hashType);
    }
    leafLookup(leaf) {
        return (this.hashLookup[StarknetMerkleTree.leafHash(leaf, this.hashType)] ??
            throwError(`'This leaf is not in tree': ${leaf}`));
    }
    /**
     * Returns a proof for the ith value in the tree. Indices refer to
     * the position of the values in the array from which the tree was constructed.
     * Also accepts a value instead of an index, but this will be less efficient.
     * It will fail if the value is not found in the tree.
     *
     * @param leaf - the position of construction, or the data contained in a leaf.
     * @returns the proof, to provide to the smart-contract.
     * @example
     * ```typescript
     * const proof = tree.getProof(3);
     * const proof = tree.getProof(["0x43af5", '100']);
     * }
     * ```
     */
    getProof(leaf) {
        const valueIndex = typeof leaf === 'number' ? leaf : this.leafLookup(leaf);
        this.validateValue(valueIndex);
        // rebuild tree index and generate proof
        const { treeIndex } = this.values[valueIndex];
        const proof = getProof(this.tree, treeIndex);
        // sanity check proof
        if (!this.internVerify(this.tree[treeIndex], proof)) {
            throw new Error('Unable to prove value');
        }
        return proof.map(biToHex);
    }
    /**
     * Returns a boolean that is `true` when the proof verifies that
     * the value is contained in the tree.
     * @remarks
     * This job is normally made by the smart-contract.
     * Present here just to be able to check in the DAPP.
     *
     * @param leaf - the position of construction, or the data contained in a leaf.
     * @param proof - proof obtained with {@link getProof}.
     * @returns verification that the leaf is present in the tree,
     * without using the tree content.
     * @example
     * ```typescript
     * const result = tree.verify(3, proof);
     * const result = tree.verify(["0x34e67d", '100'], proof);
     * ```
     */
    verify(leaf, proof) {
        const adaptedProof = proof.map(StarknetMerkleTree.adaptInputItem);
        return this.internVerify(this.getLeafHash(leaf), adaptedProof.map(BigInt));
    }
    internVerify(leafHash, proof) {
        const impliedRoot = processProof(leafHash, proof, this.hashType);
        return impliedRoot === this.tree[0];
    }
    checkBounds(array, index) {
        if (index < 0 || index >= array.length) {
            throw new Error('Index out of bounds');
        }
    }
    validateValue(valueIndex) {
        this.checkBounds(this.values, valueIndex);
        const { value, treeIndex } = this.values[valueIndex];
        this.checkBounds(this.tree, treeIndex);
        const leafHash = hashDataToBigint(value, this.hashType);
        if (!(leafHash === this.tree[treeIndex])) {
            throw new Error('Merkle tree does not contain the expected value');
        }
        return leafHash;
    }
    getLeafHash(leaf) {
        if (typeof leaf === 'number') {
            return this.validateValue(leaf);
        }
        if (typeof leaf === 'string') {
            return hashDataToBigint(StarknetMerkleTree.adaptInputItem(leaf), this.hashType);
        }
        const adaptedLeaf = leaf.map(StarknetMerkleTree.adaptInputItem);
        return hashDataToBigint(adaptedLeaf, this.hashType);
    }
}
exports.StarknetMerkleTree = StarknetMerkleTree;
//# sourceMappingURL=index.js.map